:source-highlighter: pygments

:zero_reg: footnote:[Obviously the zero register is not really a variable.  I never understood how people could say "const variable" with a straight face, it's literally an oxymoron.]

= Chapter 6: Floating Point Types

Up to this point we haven't really mentioned floating point values or instructions
at all, except how to declare them in the `.data` section and the syscalls for
reading and printing them.  There are two reasons we've left them alone till now.
First, they use a whole separate set of registers and opcodes.  Secondly, and
partly because of the first reason, most MIPS college courses do not ever require
you to know or use floating point values.  Since this book is targeted at college
students, if you know you won't need to know this feel free to skip this chapter.

=== Floating Point Registers

While the greensheet contains a nice table for the normal registers it is completely
lacking for the floating point registers.  There are 32 32-bit floating point registers.
You can use them all for floats but they're are paired even-odd for doubles.  In other
words you can only use even numbers for doubles, because storing a double at $f0 actually
uses $f0 and $f1 because it takes 64 bits/8 bytes.

As far as the calling conventions for floating point registers, it is actually hard
to find anything definitive even for the basics.  Obviously you could make up your own
but the tiny code snippet in Patterson and Hennessy was at least consistent with
this old website so I'll go with that.  I have seen at least one course page where
the prof wanted _all_ float registers preserved which seems excessive and ridiculous
but prof's are gonna prof.

.MIPS Floating Point Registers and Uses
[cols="1,2,2"]
|===
| Name | Use | Preserved Across a Call

| $f0-$f2 | Function Results | No

| $f4-$f10 | Temporaries | No

| $f12-f14 | Arguments | No

| $f16-f18 | Temporaries | No

| $f20-f30 | Saved Temporaries | Yes

|===

This table is based on doubles so it may look like it's skipping odd registers but
they're included where the even they're paired with is.  So, for example you actually
have 4 registers for float arguments `$f12` through `$f15` but only 2 for doubles
`$f12` and `f14`.  Similarly you have 12 saved registers for floats but 6 for doubles.


.MIPS floating point instructions (and pseudoinstructions)
[cols="3,1,2,2"]
|===
| Name | Opcode | Format | Operation

| Load Word to Coprocessor 1 | lwc1 (or l.s) | lwc1 ft, n(rs)  | F[ft] = M[R[rs]+n]

| Store Word from Coprocessor 1 | swc1 (or s.s) | lwc1 ft, n(rs)  | M[R[rs]+n] = F[ft]

| Load Double to Coprocessor 1 | ldc1 (or l.d) | ldc1 ft, n(rs)  | F[ft] = M[R[rs]+n]; F[ft+1] = M[R[rs]+n+4]

| Store Double from Coprocessor 1 | sdc1 (or s.d) | sdc1 ft, n(rs)  | M[R[rs]+n] = F[ft]; M[R[rs]+n+4] = F[ft+1]

| Absolute Value | abs._x_ | abs.x fs, ft | F[fs] = (F[ft] > 0) ? F[ft] : -F[ft]

| Add | add._x_ | add.x fd, fs, ft | F[fd] = F[fs] + F[ft]

| Subtract | sub._x_ | sub.x fd, fs, ft | F[fd] = F[fs] - F[ft]

| Multiply | mul._x_ | mul.x fd, fs, ft | F[fd] = F[fs] * F[ft]

| Divide | div._x_ | div.x fd, fs, ft | F[fd] = F[fs] / F[ft]

| Negation | neg._x_ | neg.x fs, ft | F[fs] = -F[ft]


|===

With all of the opcodes that end in ._x_, the x is either s for single
precision or d for double precision.






== Conclusion

