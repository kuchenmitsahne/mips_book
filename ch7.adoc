:source-highlighter: pygments

:label_addresses: footnote:[https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html]


= Chapter 7: Tips and Tricks

This chapter is a grab bag of things you can do to improve your MIPS
programs and make your life easier.

== Improving Readability

There are lots of things you can do to make your programs more readable.

=== Formatting

You may have noticed I have a general format I like to follow when writing
MIPS (or any) assembly.  The guidelines I use are the following

. 1 indent for all code excluding labels/macros/constants.
+
I use hard tabs set to a width of 4 but it reall doesn't matter as long as
it's just 1 indent according to your preferences.

. Use *spaces* to align the first operand of all instructions (syscall obviously
+
doesn't have any) out far enough.  Given my 4 space tabs, this usually means column
11-13 for me.  The reason to use spaces is to prevent the circumstances that gave
hard tabs a bad name.  When you use hard tabs for alignment, rather than indentation,
and then someone else opens your code with their tab set to a different width,
suddenly everything looks like crap.  Tabs for indentation, spaces for alignment.
Or as is increasingly common (thanks Python), spaces for everything but I refuse
to do that to the poor planet.{green_tabs}

. A comma and a single space between operands.  The simulators don't actually
+
require the comma but since other assembly languages/assemblers do, you might
as well get used to it.  Besides I think it's easier to read with the comma,
though that might just be me comparing it to passing arguments to a function.

. Comment every line or group of closely related lines with the purpose,
+
often just the equivalent C code.  You can relax this a little as you get
more experience.

. Use a blank line to separate logically grouped lines of code.  While you
+
can smash everything together vertically, I definitely wouldn't recommend it,
even less than I would in a higher level language.

. Put the `.data` section at the top, similar to declaring globals in C.
+
There are exceptions for this.  When dealing with a larger program with lots
of strings, it can be convienent to have multiple `.data` sections with the
strings you're using declared close to where you use them.  The downside is
you have to keep swapping back and forth between `.text` and `.data`.

=== Misc. General Tips

. Try to use registers starting from 0 and working your way up.  It helps
+
you keep track of where things are (esp. combined with the comments). This
obviously can fall apart when you discover you forgot something or need to
modify the code later and it's often not worth changing all the registers
you're already using just so you have that nice sequence.  When that happens
I'll sometimes just pick the other end of sequence (ie `$t9` or `$s7`) since
if it's out of order I might as well make it obvious.

. Minimize your jumps, labels, and especially your level of nested loops.
+
This was already covered in the chapters on branching and loops but it bears
repeating.

. In your prologue save `$ra` first (at the top of the stack) if necessary
+
and all s regs you used (starting at `$s0`) in order going down.  Then copy
paste the whole thing to the bottom, move the first line to the bottom and
change the number to positive and change all the `sw` to `lw`.

....
func:
	addi    $sp, $sp, -20
	sw      $ra, 0($sp)
	sw      $s0, 4($sp)
	sw      $s1, 8($sp)
	sw      $s2, 12($sp)
	sw      $s3, 16($sp)

	# body of func here that calls another function or functions
	# and needs to preserve 4 values across at least one of those calls

	lw      $ra, 0($sp)
	lw      $s0, 4($sp)
	lw      $s1, 8($sp)
	lw      $s2, 12($sp)
	lw      $s3, 16($sp)
	addi    $sp, $sp, 20
....


=== Constants

One of the easiest things you can do to make your programs more readable
is use defined constants in your programs.  Both MARS and SPIM have ways
of defining constants similar to how C defines macro constants; ie they
aren't "constant variables" that take up space in memory, it's as if a
search+replace was done on them right before assembling the program.

Let's look at our Hello World program using constants for SPM and MARS

SPIM:

[source,mips,linenums]
----
sys_print_str = 4
sys_exit = 10

.data
hello:   .asciiz "Hello World!\n"

.text
main:
	li      $v0, sys_print_str
	la      $a0, hello  # load address of string to print into a0
	syscall

	li      $v0, sys_exit
	syscall
----

MARS:

[source,mips,linenums]
----
.eqv sys_print_str 4
.eqv sys_exit 10

.data
hello:   .asciiz "Hello World!\n"

.text
main:
	li      $v0, sys_print_str
	la      $a0, hello  # load address of string to print into a0
	syscall

	li      $v0, sys_exit
	syscall
----

=== Macros

MARS supports function style macros that can shorten your code and improve
readability in some cases (though I feel it can also make it worse or be a wash).

The syntax looks like this:

[source,mips,linenums]
----
.macro macroname
instr1  a, b, c
instr2, b, d
# etc.
.end_macro

# or with parameters
.macro macroname(%arg1)
instr1    a, %arg1
instr2    c, d, e
# etc.
.end_macro
----

Some common examples are using them to print strings:

[source,mips,linenums]
----
.macro print_str_label(%x)
li     $v0, 4
la     $a0, %x
syscall
.end_macro

.macro print_str(%str)
.data
str: .asciiz %str
.text
li     $v0, 4
la     $a0, str
syscall
.end_macro

.data

str1:   .asciiz "Hello 1\n"

.text
# in use:
	print_str_label(str1)

	print_str("Hello World\n")

	...
----

You can see an example program in macros.s

Unfortunately, as far as I can tell SPIM does not support function style macros
despite what MARS's documentation implies about using a $ instead of a % for arguments.

=== Switch-Case Statements

It is relatively common in programming to have to compare a integral type variable
(ie basically any built in type but float and double) against a bunch of different
constants and do something different based on what it matches or if it matches none.

This could be done with a long if-else-if chain, but the longer the chain the more
likely the programmer is to choose a switch-case statement instead.

Here's a pretty short/simple example in C:

[source,c,linenums]
----
	printf("Enter your grade (capital): ");
	int grade = getchar();
	switch (grade) {
	case 'A': puts("Excellent job!"); break;
	case 'B': puts("Good job!"); break;
	case 'C': puts("At least you passed?"); break;
	case 'D': puts("Probably should have dropped it..."); break;
	case 'F': puts("Did you even know you were signed up for the class?"); break;
	default: puts("You entered and invalid grade!");
	}
----

You could translate this to its eqivalent if-else chain and handle it just like we
cover in the chapter on branching.  However, imagine if this switch statment had
a dozen cases, two dozen etc.  The MIPS code for that quickly becomes long and ugly.

So what if we implemented the switch in MIPS the same way it is semantically in C?
The same way compilers often (but not necessarily) use?  Well before we do that,
what is a switch actually doing?  It is _jumping_ to a specific case label based
on the value in the specified variable.  It then starts executing, falling through
any other labels, till it hits a `break` which will jump to the end of the switch
block.  If the value does have its own case label, it will jump to the default
label.

Compilers handle it by creating what's called a jump table, basically an array
of label addresses and using the variable to calculate an index in the table
to use to jump to.

The C eqivalent of that would look like this:


[source,c,linenums]
----
include::code/switch.c[]
----

The `&&` and `goto *var` syntax are actually not standard C/C++ but are GNU
extensions that are supported in gcc (naturally) and clang, possibly others.{label_addresses}

Notice how the size of the jump table is the value of the highest valued label
minus the lowest + 1.  That's why we subtract the lowest value to shift the range
to start at 0 for the indexing.  Secondly, any values without labels within that
range are filled with the default label address.  Lastly there has to be an initial
check for values outside the range to jump to default otherwise you could get an
error from an invalid access outside of the array's bounds.

The same program/code in MIPS would look like this:

[source,mips,linenums]
----
include::code/switch.s[]
----

It's easy to forget that `jr` does not actually stand for "jump return" even though
it's almost always used for that purpose.  Instead it stands for "jump register"
and we can use it to do the eqivalent of the computed goto statement in C.

While this example probably wasn't worth making switch style, because the overhead
and extra code of making the table and preparing to jump balanced out or even
outweighed the savings of a branch instruction for every case, as the number
of options increases, the favor tilts toward using a jump table like this as
long as the range of isn't too sparse.  If the range of values is is the 100's
or 1000's but you only have cases for a dozen or so, then obviously that isn't worth
it to create a table that large just to fill it almost entirely with the default label.

Just to reiterate, remember it is not about the magnitude of the actual values
you're looking for, just the difference between the highest and lowest because
high - low + 1 is the size of your table.


