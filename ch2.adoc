:mars_syscalls: footnote:[https://courses.missouristate.edu/KenVollmar/mars/Help/SyscallHelp.html]

= Chapter 2: System Calls

We mentioned system calls (aka syscalls from now on) in chapter 0 when we were
going over our "Hello World" program, but what exactly are they?

Essentially, they are the built in functions of a operating system, in this case,
the simple operating system of the MIPS simulators.  They provide access to all the
fundamental features, like input and output to/from both the console and files,
allocating memory, and exiting.  That covers all the 17 syscalls supported by spim,
but MARS supports many more, for things from playing MIDI sounds, to getting a random
number, to creating GUI dialogs{mars_syscalls}

NOTE: Except for the MARS specific chapters/sections, I'll be sticking to SPIM compatible
code throughout this book, meaning we only use the first 17 syscalls, and don't get
to use some of the syntactic sugar available in MARS.

.SPIM supported syscalls
.MIPS data types
[cols="3,1,6,6"]
|===
| Name | $v0 | Arguments | Result

| print integer | 1 | $a0 = integer to print |

| print float | 2 | $f12 = float to print |

| print double | 3 | $f12 = double to print |

| print string | 4 | $a0 = address of string |

| read integer | 5 | | $v0 = integer read

| read float | 6 | |$f0 = float read

| read double | 7 | | $f0 = double read

| read string | 8 | $a0 = address of input buffer +
$a1 = buffer size | works like C's fgets

| sbrk | 9 | $a0 = size in bytes to allocate | $v0 = address of allocated memory (sbrk is basically malloc but there is no free)

| exit | 10 | | program terminates

| print character | 11 | $a0 = character to print (ascii value) |

| read character | 12 | | $v0 = character read

| open file | 13 | $a0 = address of filename +
$a1 = flags +
$a2 = mode | $v0 = file descriptor (negative if error)

| read from file | 14 | $a0 = file descriptor +
$a1 = address of input buffer +
$a2 = max characters to read | $v0 = number of characters read, 0 for end-of-file, negative for error

| write to file | 15 | $a0 = file descriptor +
$a1 = address of output buffer +
$a2 = number of characters to write | $v0 = number of characters written, negative for error

| close file | 16 | $a0 = file descriptor |

| exit2 | 17 | $a0 = termination result | program terminates, returning number in $a0 (only meaningful when run in the terminal, ignored in GUI)

|===

As you can see you it's just the basics.  You can read or write the different types,
cdo file I/O using calls identical to POSIX functions (open, read, write, close;
see man pages), allocate memory, and exit.  Even so, they're sufficient to build
anything you want.



